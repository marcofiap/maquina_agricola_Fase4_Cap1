import streamlit as st
import requests
import pandas as pd
import plotly.graph_objs as go
import plotly.express as px
from datetime import datetime
import time
import sys
import os
import numpy as np
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, accuracy_score, classification_report
from sklearn.preprocessing import StandardScaler
import joblib

# Importa as configura√ß√µes do banco
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

from config.database_config import _config as DatabaseConfig, conectar_postgres

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="FarmTech Solutions Dashboard",
    page_icon="üå±",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Inicializa√ß√£o precoce do session_state
if 'current_page' not in st.session_state:
    st.session_state.current_page = "dashboard"

if 'crud_opcao' not in st.session_state:
    st.session_state.crud_opcao = "Selecione uma opera√ß√£o..."

if 'analytics_opcao' not in st.session_state:
    st.session_state.analytics_opcao = "Selecione uma an√°lise..."

# URL do servidor Flask local
FLASK_SERVER_URL = "http://127.0.0.1:8000/get_data"

# === FUN√á√ïES CRUD PARA STREAMLIT ===

def crud_inserir_dados():
    """Interface Streamlit para inserir novos dados"""
    st.subheader("üì• Inserir Nova Leitura")
    
    with st.form("inserir_dados_form"):
        # Data/hora
        col1, col2 = st.columns(2)
        with col1:
            usar_atual = st.checkbox("Usar data/hora atual", value=True)
        with col2:
            if not usar_atual:
                data_hora = st.datetime_input("Data/Hora da Leitura", datetime.now())
            else:
                data_hora = datetime.now()
        
        # Sensores
        col1, col2, col3 = st.columns(3)
        with col1:
            umidade = st.number_input("Umidade (%)", min_value=0.0, max_value=100.0, value=50.0, step=0.1)
        with col2:
            temperatura = st.number_input("Temperatura (¬∞C)", min_value=-50.0, max_value=70.0, value=25.0, step=0.1)
        with col3:
            ph = st.number_input("pH", min_value=0.0, max_value=14.0, value=7.0, step=0.1)
        
        # Estados
        col1, col2, col3 = st.columns(3)
        with col1:
            fosforo = st.selectbox("F√≥sforo", ["Ausente", "Presente"]) == "Presente"
        with col2:
            potassio = st.selectbox("Pot√°ssio", ["Ausente", "Presente"]) == "Presente"
        with col3:
            bomba = st.selectbox("Bomba", ["Desligada", "Ligada"]) == "Ligada"
        
        submitted = st.form_submit_button("‚úÖ Inserir Dados")
        
        if submitted:
            try:
                conn, cursor = conectar_postgres()
                if conn:
                    cursor.execute(f"""
                        INSERT INTO {DatabaseConfig.SCHEMA}.leituras_sensores 
                        (data_hora_leitura, umidade, temperatura, ph, fosforo, potassio, bomba_dagua)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (data_hora, umidade, temperatura, ph, fosforo, potassio, bomba))
                    conn.commit()
                    st.success("‚úÖ Dados inseridos com sucesso!")
                    st.balloons()
                    cursor.close()
                    conn.close()
                    st.cache_data.clear()  # Limpa cache para mostrar novos dados
                else:
                    st.error("‚ùå Erro ao conectar com o banco de dados")
            except Exception as e:
                st.error(f"‚ùå Erro ao inserir dados: {e}")

def crud_listar_dados():
    """Interface Streamlit para listar dados"""
    st.subheader("üìÑ Gerenciar Leituras")
    
    try:
        conn, cursor = conectar_postgres()
        if conn:
            cursor.execute(f"""
                SELECT id, data_hora_leitura, criacaots, umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                ORDER BY data_hora_leitura DESC
                LIMIT 50
            """)
            rows = cursor.fetchall()
            
            if rows:
                # Converte para DataFrame
                df = pd.DataFrame(rows, columns=[
                    'ID', 'Data/Hora Leitura', 'Cria√ß√£o', 'Umidade', 'Temperatura', 
                    'pH', 'F√≥sforo', 'Pot√°ssio', 'Bomba'
                ])
                
                # Formata as colunas boolean
                df['F√≥sforo'] = df['F√≥sforo'].apply(lambda x: "‚úÖ Presente" if x else "‚ùå Ausente")
                df['Pot√°ssio'] = df['Pot√°ssio'].apply(lambda x: "‚úÖ Presente" if x else "‚ùå Ausente")
                df['Bomba'] = df['Bomba'].apply(lambda x: "‚úÖ Ligada" if x else "‚ùå Desligada")
                
                st.dataframe(df, use_container_width=True, height=400)
                st.info(f"üìä Mostrando √∫ltimos 50 registros de {len(rows)} encontrados")
            else:
                st.warning("‚ö†Ô∏è Nenhum dado encontrado")
            
            cursor.close()
            conn.close()
    except Exception as e:
        st.error(f"‚ùå Erro ao listar dados: {e}")

def crud_atualizar_dados():
    """Interface Streamlit para atualizar dados"""
    st.subheader("‚úèÔ∏è Atualizar Leitura")
    
    # Busca registros para sele√ß√£o
    try:
        conn, cursor = conectar_postgres()
        if conn:
            cursor.execute(f"""
                SELECT id, data_hora_leitura, umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                ORDER BY data_hora_leitura DESC
                LIMIT 20
            """)
            registros = cursor.fetchall()
            
            if registros:
                # Cria op√ß√µes para o selectbox
                opcoes = []
                for reg in registros:
                    data_formatada = reg[1].strftime("%Y-%m-%d %H:%M:%S") if reg[1] else "N/A"
                    opcoes.append(f"ID {reg[0]} - {data_formatada} (T:{reg[3]}¬∞C, H:{reg[2]}%)")
                
                registro_selecionado = st.selectbox("Selecione o registro para atualizar:", opcoes)
                
                if registro_selecionado:
                    # Extrai o ID do registro selecionado
                    id_registro = int(registro_selecionado.split(" ")[1])
                    
                    # Busca dados atuais do registro
                    cursor.execute(f"""
                        SELECT umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                        FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                        WHERE id = %s
                    """, (id_registro,))
                    dados_atuais = cursor.fetchone()
                    
                    if dados_atuais:
                        with st.form("atualizar_dados_form"):
                            st.info(f"üìã Atualizando registro ID: {id_registro}")
                            
                            # Campos com valores atuais
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                nova_umidade = st.number_input("Nova Umidade (%)", 
                                                             min_value=0.0, max_value=100.0, 
                                                             value=float(dados_atuais[0]), step=0.1)
                            with col2:
                                nova_temperatura = st.number_input("Nova Temperatura (¬∞C)", 
                                                                 min_value=-50.0, max_value=70.0, 
                                                                 value=float(dados_atuais[1]), step=0.1)
                            with col3:
                                novo_ph = st.number_input("Novo pH", 
                                                        min_value=0.0, max_value=14.0, 
                                                        value=float(dados_atuais[2]), step=0.1)
                            
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                novo_fosforo = st.selectbox("Novo F√≥sforo", 
                                                          ["Ausente", "Presente"], 
                                                          index=1 if dados_atuais[3] else 0) == "Presente"
                            with col2:
                                novo_potassio = st.selectbox("Novo Pot√°ssio", 
                                                           ["Ausente", "Presente"], 
                                                           index=1 if dados_atuais[4] else 0) == "Presente"
                            with col3:
                                nova_bomba = st.selectbox("Nova Bomba", 
                                                        ["Desligada", "Ligada"], 
                                                        index=1 if dados_atuais[5] else 0) == "Ligada"
                            
                            submitted = st.form_submit_button("‚úÖ Atualizar Registro")
                            
                            if submitted:
                                try:
                                    cursor.execute(f"""
                                        UPDATE {DatabaseConfig.SCHEMA}.leituras_sensores
                                        SET umidade = %s, temperatura = %s, ph = %s, fosforo = %s, potassio = %s, bomba_dagua = %s
                                        WHERE id = %s
                                    """, (nova_umidade, nova_temperatura, novo_ph, novo_fosforo, novo_potassio, nova_bomba, id_registro))
                                    
                                    if cursor.rowcount > 0:
                                        conn.commit()
                                        st.success("‚úÖ Registro atualizado com sucesso!")
                                        st.cache_data.clear()
                                    else:
                                        st.warning("‚ö†Ô∏è Nenhum registro foi atualizado")
                                except Exception as e:
                                    st.error(f"‚ùå Erro ao atualizar: {e}")
            else:
                st.warning("‚ö†Ô∏è Nenhum registro encontrado")
            
            cursor.close()
            conn.close()
    except Exception as e:
        st.error(f"‚ùå Erro ao buscar registros: {e}")

def crud_remover_dados():
    """Interface Streamlit para remover dados"""
    st.subheader("üóëÔ∏è Remover Leitura")
    
    try:
        conn, cursor = conectar_postgres()
        if conn:
            cursor.execute(f"""
                SELECT id, data_hora_leitura, umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                ORDER BY data_hora_leitura DESC
                LIMIT 20
            """)
            registros = cursor.fetchall()
            
            if registros:
                # Cria op√ß√µes para o selectbox
                opcoes = ["Selecione um registro..."]
                for reg in registros:
                    data_formatada = reg[1].strftime("%Y-%m-%d %H:%M:%S") if reg[1] else "N/A"
                    opcoes.append(f"ID {reg[0]} - {data_formatada} (T:{reg[3]}¬∞C, H:{reg[2]}%)")
                
                registro_selecionado = st.selectbox("Selecione o registro para remover:", opcoes)
                
                if registro_selecionado != opcoes[0]:
                    # Extrai o ID do registro selecionado
                    id_registro = int(registro_selecionado.split(" ")[1])
                    
                    # Busca dados completos do registro
                    cursor.execute(f"""
                        SELECT id, data_hora_leitura, umidade, temperatura, ph, fosforo, potassio, bomba_dagua
                        FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                        WHERE id = %s
                    """, (id_registro,))
                    registro = cursor.fetchone()
                    
                    if registro:
                        st.warning("‚ö†Ô∏è Registro a ser removido:")
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.info(f"**ID:** {registro[0]}")
                            st.info(f"**Data/Hora:** {registro[1]}")
                            st.info(f"**Umidade:** {registro[2]}%")
                            st.info(f"**Temperatura:** {registro[3]}¬∞C")
                        
                        with col2:
                            st.info(f"**pH:** {registro[4]}")
                            st.info(f"**F√≥sforo:** {'‚úÖ Presente' if registro[5] else '‚ùå Ausente'}")
                            st.info(f"**Pot√°ssio:** {'‚úÖ Presente' if registro[6] else '‚ùå Ausente'}")
                            st.info(f"**Bomba:** {'‚úÖ Ligada' if registro[7] else '‚ùå Desligada'}")
                        
                        # Confirma√ß√£o
                        confirmar = st.checkbox("‚ö†Ô∏è Confirmo que desejo remover este registro")
                        
                        if confirmar and st.button("üóëÔ∏è REMOVER REGISTRO", type="primary"):
                            try:
                                cursor.execute(f"DELETE FROM {DatabaseConfig.SCHEMA}.leituras_sensores WHERE id = %s", (id_registro,))
                                if cursor.rowcount > 0:
                                    conn.commit()
                                    st.success("‚úÖ Registro removido com sucesso!")
                                    st.cache_data.clear()
                                    time.sleep(1)
                                    st.rerun()
                                else:
                                    st.warning("‚ö†Ô∏è Nenhum registro foi removido")
                            except Exception as e:
                                st.error(f"‚ùå Erro ao remover: {e}")
            else:
                st.warning("‚ö†Ô∏è Nenhum registro encontrado")
            
            cursor.close()
            conn.close()
    except Exception as e:
        st.error(f"‚ùå Erro ao buscar registros: {e}")

def crud_estatisticas():
    """Interface Streamlit para mostrar estat√≠sticas"""
    st.subheader("üìä Estat√≠sticas dos Dados")
    
    try:
        conn, cursor = conectar_postgres()
        if conn:
            cursor.execute(f"""
                SELECT 
                    COUNT(*) as total_registros,
                    AVG(umidade) as umidade_media,
                    MIN(umidade) as umidade_min,
                    MAX(umidade) as umidade_max,
                    AVG(temperatura) as temp_media,
                    MIN(temperatura) as temp_min,
                    MAX(temperatura) as temp_max,
                    AVG(ph) as ph_medio,
                    MIN(ph) as ph_min,
                    MAX(ph) as ph_max
                FROM {DatabaseConfig.SCHEMA}.leituras_sensores
            """)
            stats = cursor.fetchone()
            
            if stats and stats[0] > 0:
                # M√©tricas principais
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("üìä Total de Registros", f"{stats[0]:,}")
                
                with col2:
                    st.metric("üíß Umidade M√©dia", f"{stats[1]:.1f}%")
                
                with col3:
                    st.metric("üå°Ô∏è Temperatura M√©dia", f"{stats[4]:.1f}¬∞C")
                
                with col4:
                    st.metric("‚öóÔ∏è pH M√©dio", f"{stats[7]:.1f}")
                
                # Estat√≠sticas detalhadas
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.info("üíß **UMIDADE**")
                    st.write(f"M√©dia: {stats[1]:.1f}%")
                    st.write(f"M√≠nima: {stats[2]:.1f}%")
                    st.write(f"M√°xima: {stats[3]:.1f}%")
                
                with col2:
                    st.info("üå°Ô∏è **TEMPERATURA**")
                    st.write(f"M√©dia: {stats[4]:.1f}¬∞C")
                    st.write(f"M√≠nima: {stats[5]:.1f}¬∞C")
                    st.write(f"M√°xima: {stats[6]:.1f}¬∞C")
                
                with col3:
                    st.info("‚öóÔ∏è **pH**")
                    st.write(f"M√©dio: {stats[7]:.1f}")
                    st.write(f"M√≠nimo: {stats[8]:.1f}")
                    st.write(f"M√°ximo: {stats[9]:.1f}")
                
            else:
                st.warning("‚ö†Ô∏è Nenhum dado dispon√≠vel para estat√≠sticas")
            
            cursor.close()
            conn.close()
    except Exception as e:
        st.error(f"‚ùå Erro ao calcular estat√≠sticas: {e}")

def crud_consulta_umidade():
    """Interface Streamlit para consulta por umidade"""
    st.subheader("üîé Consulta por Umidade")
    
    col1, col2 = st.columns(2)
    with col1:
        limite = st.number_input("Valor de refer√™ncia (%)", min_value=0.0, max_value=100.0, value=50.0, step=0.1)
    with col2:
        condicao = st.selectbox("Condi√ß√£o", ["acima", "abaixo"])
    
    if st.button("üîç Buscar"):
        try:
            conn, cursor = conectar_postgres()
            if conn:
                if condicao == 'acima':
                    cursor.execute(f"""
                        SELECT id, data_hora_leitura, umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                        FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                        WHERE umidade > %s 
                        ORDER BY data_hora_leitura DESC
                    """, (limite,))
                else:
                    cursor.execute(f"""
                        SELECT id, data_hora_leitura, umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                        FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                        WHERE umidade < %s 
                        ORDER BY data_hora_leitura DESC
                    """, (limite,))
                
                rows = cursor.fetchall()
                
                if rows:
                    st.success(f"üîç Encontrados {len(rows)} registros com umidade {condicao} de {limite}%")
                    
                    # Converte para DataFrame
                    df = pd.DataFrame(rows, columns=[
                        'ID', 'Data/Hora', 'Umidade', 'Temperatura', 'pH', 'F√≥sforo', 'Pot√°ssio', 'Bomba'
                    ])
                    
                    # Formata as colunas boolean
                    df['F√≥sforo'] = df['F√≥sforo'].apply(lambda x: "‚úÖ" if x else "‚ùå")
                    df['Pot√°ssio'] = df['Pot√°ssio'].apply(lambda x: "‚úÖ" if x else "‚ùå")
                    df['Bomba'] = df['Bomba'].apply(lambda x: "‚úÖ" if x else "‚ùå")
                    
                    st.dataframe(df, use_container_width=True)
                else:
                    st.warning("‚ö†Ô∏è Nenhum registro encontrado com esse crit√©rio")
                
                cursor.close()
                conn.close()
        except Exception as e:
            st.error(f"‚ùå Erro na consulta: {e}")

# === FUN√á√ïES PARA AN√ÅLISE ESTAT√çSTICA COM R ===

def exportar_dados_para_r():
    """Exporta dados do PostgreSQL para CSV que ser√° usado pelo R"""
    try:
        conn, cursor = conectar_postgres()
        if conn:
            # Query para buscar todos os dados necess√°rios para an√°lise
            cursor.execute(f"""
                SELECT data_hora_leitura as timestamp, umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                ORDER BY data_hora_leitura
            """)
            rows = cursor.fetchall()
            
            if rows:
                # Converte para DataFrame
                df = pd.DataFrame(rows, columns=[
                    'timestamp', 'umidade', 'temperatura', 'ph', 'fosforo', 'potassio', 'bomba_dagua'
                ])
                
                # Salva no diret√≥rio de an√°lise estat√≠stica
                output_path = os.path.join(parent_dir, 'analise_estatistica', 'leituras_sensores.csv')
                df.to_csv(output_path, index=False)
                
                st.success(f"‚úÖ Dados exportados com sucesso! {len(rows)} registros salvos em:")
                st.code(output_path)
                return True
            else:
                st.warning("‚ö†Ô∏è Nenhum dado encontrado para exportar")
                return False
            
            cursor.close()
            conn.close()
    except Exception as e:
        st.error(f"‚ùå Erro ao exportar dados: {e}")
        return False

def executar_script_r():
    """Executa o script R de an√°lise estat√≠stica"""
    try:
        # Caminho para o script R
        script_path = os.path.join(parent_dir, 'analise_estatistica', 'AnaliseEstatisticaBD.R')
        analise_dir = os.path.join(parent_dir, 'analise_estatistica')
        
        if not os.path.exists(script_path):
            st.error(f"‚ùå Script R n√£o encontrado: {script_path}")
            return False
            
        # Executa o script R
        import subprocess
        
        with st.spinner("üîÑ Executando an√°lise estat√≠stica com R..."):
            result = subprocess.run(['Rscript', script_path], 
                                  cwd=analise_dir,
                                  capture_output=True, 
                                  text=True,
                                  timeout=60)
        
        if result.returncode == 0:
            st.success("‚úÖ An√°lise R executada com sucesso!")
            if result.stdout:
                st.text("üìã Output do R:")
                st.code(result.stdout)
            return True
        else:
            st.error("‚ùå Erro na execu√ß√£o do script R:")
            st.code(result.stderr)
            return False
            
    except subprocess.TimeoutExpired:
        st.error("‚ùå Timeout: Script R demorou mais de 60 segundos")
        return False
    except FileNotFoundError:
        st.error("‚ùå R n√£o encontrado no sistema. Certifique-se de que o R est√° instalado e no PATH")
        return False
    except Exception as e:
        st.error(f"‚ùå Erro ao executar script R: {e}")
        return False

def mostrar_resumo_estatistico():
    """Mostra o resumo estat√≠stico gerado pelo R"""
    try:
        resumo_path = os.path.join(parent_dir, 'analise_estatistica', 'resumo_estatistico.csv')
        
        if os.path.exists(resumo_path):
            df_resumo = pd.read_csv(resumo_path)
            st.subheader("üìä Resumo Estat√≠stico (Gerado pelo R)")
            st.dataframe(df_resumo, use_container_width=True)
            
            # Bot√£o para download
            csv_data = df_resumo.to_csv(index=False)
            st.download_button(
                label="üì• Download Resumo Estat√≠stico",
                data=csv_data,
                file_name="resumo_estatistico.csv",
                mime="text/csv"
            )
            return True
        else:
            st.warning("‚ö†Ô∏è Arquivo de resumo estat√≠stico n√£o encontrado. Execute a an√°lise primeiro.")
            return False
            
    except Exception as e:
        st.error(f"‚ùå Erro ao ler resumo estat√≠stico: {e}")
        return False

def verificar_ambiente_r():
    """Verifica se o ambiente R est√° configurado corretamente"""
    try:
        import subprocess
        result = subprocess.run(['R', '--version'], capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            st.success("‚úÖ R est√° instalado e funcionando")
            st.text("üìã Vers√£o do R:")
            st.code(result.stdout.split('\n')[0])
            return True
        else:
            st.error("‚ùå Problema com a instala√ß√£o do R")
            return False
            
    except FileNotFoundError:
        st.error("‚ùå R n√£o encontrado. Instale o R para usar as an√°lises estat√≠sticas.")
        st.markdown("""
        **Como instalar o R:**
        - **macOS**: `brew install r` ou baixe de https://cran.r-project.org/
        - **Ubuntu**: `sudo apt-get install r-base`
        - **Windows**: Baixe de https://cran.r-project.org/
        """)
        return False
    except Exception as e:
        st.error(f"‚ùå Erro ao verificar R: {e}")
        return False

def pagina_analytics_r():
    """P√°gina dedicada √† an√°lise estat√≠stica com R"""
    st.title("ü§ñ An√°lise Estat√≠stica com R")
    st.markdown("**An√°lise preditiva e estat√≠stica usando linguagem R**")
    
    # Bot√£o para voltar ao dashboard
    if st.button("üè† Voltar ao Dashboard", type="primary"):
        st.session_state.current_page = "dashboard"
        st.session_state.analytics_opcao = "Selecione uma an√°lise..."
        st.rerun()
    
    st.markdown("---")
    
    # Informa√ß√µes do sistema
    col1, col2, col3 = st.columns(3)
    with col1:
        st.info(f"üèóÔ∏è **Schema:** {DatabaseConfig.SCHEMA}")
    with col2:
        st.info(f"üìä **Linguagem:** R + Python")
    with col3:
        st.info(f"üìÅ **Pasta:** analise_estatistica/")
    
    st.markdown("---")
    
    # Verifica√ß√£o do ambiente R
    st.subheader("üîç Verifica√ß√£o do Ambiente")
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üîç Verificar Instala√ß√£o do R", use_container_width=True):
            verificar_ambiente_r()
    
    with col2:
        if st.button("üì§ Exportar Dados para R", use_container_width=True):
            exportar_dados_para_r()
    
    st.markdown("---")
    
    # Sele√ß√£o de an√°lises
    analytics_opcao = st.selectbox(
        "**Selecione a an√°lise desejada:**",
        [
            "Selecione uma an√°lise...",
            "üìä Executar An√°lise Estat√≠stica Completa",
            "üìà Ver Resumo Estat√≠stico",
            "üìã Status dos Arquivos R",
            "üîß Configurar Ambiente R"
        ],
        key="analytics_page_selectbox"
    )
    
    st.markdown("---")
    
    # Executa a opera√ß√£o selecionada
    if analytics_opcao == "üìä Executar An√°lise Estat√≠stica Completa":
        st.subheader("üìä An√°lise Estat√≠stica Completa")
        
        col1, col2 = st.columns(2)
        with col1:
            if st.button("1Ô∏è‚É£ Exportar Dados", use_container_width=True):
                exportar_dados_para_r()
        
        with col2:
            if st.button("2Ô∏è‚É£ Executar Script R", use_container_width=True):
                if executar_script_r():
                    st.balloons()
        
        st.markdown("---")
        st.info("üí° **Processo completo:** 1) Exporte os dados ‚Üí 2) Execute o script R ‚Üí 3) Veja os resultados")
        
    elif analytics_opcao == "üìà Ver Resumo Estat√≠stico":
        mostrar_resumo_estatistico()
        
    elif analytics_opcao == "üìã Status dos Arquivos R":
        st.subheader("üìã Status dos Arquivos R")
        
        # Verifica arquivos na pasta analise_estatistica
        analise_dir = os.path.join(parent_dir, 'analise_estatistica')
        
        arquivos_r = {
            "AnaliseEstatisticaBD.R": "Script principal de an√°lise",
            "leituras_sensores.csv": "Dados exportados para an√°lise",
            "resumo_estatistico.csv": "Resumo gerado pelo R",
            "requirements.txt": "Depend√™ncias R"
        }
        
        for arquivo, descricao in arquivos_r.items():
            arquivo_path = os.path.join(analise_dir, arquivo)
            if os.path.exists(arquivo_path):
                st.success(f"‚úÖ **{arquivo}** - {descricao}")
            else:
                st.error(f"‚ùå **{arquivo}** - {descricao} (n√£o encontrado)")
        
    elif analytics_opcao == "üîß Configurar Ambiente R":
        st.subheader("üîß Configura√ß√£o do Ambiente R")
        
        st.markdown("""
        **Pacotes R necess√°rios:**
        ```r
        install.packages(c("readr", "dplyr", "ggplot2", "lubridate", "forecast"))
        ```
        
        **Para instalar os pacotes automaticamente:**
        """)
        
        if st.button("üì¶ Instalar Pacotes R", use_container_width=True):
            try:
                import subprocess
                
                # Script R melhorado para instala√ß√£o
                install_script = '''
                # Fun√ß√£o para instalar pacotes
                install_and_load <- function(package) {
                  if (!require(package, character.only = TRUE, quietly = TRUE)) {
                    cat("Instalando pacote:", package, "\\n")
                    install.packages(package, repos = "https://cran.rstudio.com/")
                    if (require(package, character.only = TRUE, quietly = TRUE)) {
                      cat("‚úÖ", package, "instalado com sucesso\\n")
                    } else {
                      cat("‚ùå Erro ao instalar", package, "\\n")
                    }
                  } else {
                    cat("‚úÖ", package, "j√° est√° instalado\\n")
                  }
                }

                # Instalar pacotes necess√°rios
                packages <- c("readr", "dplyr", "ggplot2", "lubridate", "forecast")
                cat("=== INSTALANDO PACOTES R ===\\n")
                
                for (pkg in packages) {
                  install_and_load(pkg)
                }
                
                cat("=== INSTALA√á√ÉO CONCLU√çDA ===\\n")
                '''
                
                install_cmd = ['Rscript', '-e', install_script]
                
                with st.spinner("üì¶ Instalando pacotes R... (pode demorar alguns minutos)"):
                    result = subprocess.run(install_cmd, capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    st.success("‚úÖ Pacotes R instalados com sucesso!")
                    st.text("üìã Log da instala√ß√£o:")
                    st.code(result.stdout)
                else:
                    st.error("‚ùå Erro na instala√ß√£o dos pacotes:")
                    st.code(result.stderr)
                    st.info("üí° Tente executar manualmente no R: install.packages(c('readr', 'dplyr', 'ggplot2', 'lubridate', 'forecast'))")
            except subprocess.TimeoutExpired:
                st.error("‚ùå Timeout: Instala√ß√£o demorou mais de 5 minutos")
            except Exception as e:
                st.error(f"‚ùå Erro: {e}")
        
    else:
        st.info("üëÜ Selecione uma an√°lise no menu acima para come√ßar")
        
        # Preview da estrutura do projeto R
        st.subheader("üìÅ Estrutura do Projeto R")
        st.markdown("""
        ```
        analise_estatistica/
        ‚îú‚îÄ‚îÄ üìÑ AnaliseEstatisticaBD.R       # Script principal
        ‚îú‚îÄ‚îÄ üìä leituras_sensores.csv        # Dados para an√°lise  
        ‚îú‚îÄ‚îÄ üìà resumo_estatistico.csv       # Resultados gerados
        ‚îú‚îÄ‚îÄ üì¶ requirements.txt             # Depend√™ncias R
        ‚îî‚îÄ‚îÄ üìã README.md                    # Documenta√ß√£o
        ```
        
        **Funcionalidades dispon√≠veis:**
        - ‚úÖ Estat√≠sticas descritivas
        - ‚úÖ Correla√ß√µes entre vari√°veis
        - ‚úÖ Visualiza√ß√µes com ggplot2
        - ‚úÖ Previs√µes ARIMA para umidade
        - ‚úÖ An√°lise de s√©ries temporais
        """)

def pagina_crud():
    """P√°gina dedicada ao CRUD"""
    st.title("üóÉÔ∏è Gerenciamento de Registros")
    st.markdown("**Opera√ß√µes do Banco de Dados PostgreSQL**")
    
    # Bot√£o para voltar ao dashboard
    if st.button("üè† Voltar ao Dashboard", type="primary"):
        st.session_state.current_page = "dashboard"
        st.session_state.crud_opcao = "Selecione uma opera√ß√£o..."
        st.rerun()
    
    st.markdown("---")
    
    # Informa√ß√µes do banco
    col1, col2, col3 = st.columns(3)
    with col1:
        st.info(f"üèóÔ∏è **Schema:** {DatabaseConfig.SCHEMA}")
    with col2:
        st.info(f"üñ•Ô∏è **Host:** {DatabaseConfig.HOST}")
    with col3:
        st.info(f"üíæ **Database:** {DatabaseConfig.DATABASE}")
    
    st.markdown("---")
    
    # Sele√ß√£o de opera√ß√£o CRUD
    crud_opcao = st.selectbox(
        "**Selecione a opera√ß√£o desejada:**",
        [
            "Selecione uma opera√ß√£o...",
            "üì• Inserir Nova Leitura",
            "üìÑ Gerenciar Leituras",
            "‚úèÔ∏è Atualizar Leitura",
            "üóëÔ∏è Remover Leitura",
            "üìä Estat√≠sticas dos Dados",
            "üîé Consulta por Umidade"
        ],
        key="crud_page_selectbox"
    )
    
    st.markdown("---")
    
    # Executa a opera√ß√£o selecionada
    if crud_opcao == "üì• Inserir Nova Leitura":
        crud_inserir_dados()
    elif crud_opcao == "üìÑ Gerenciar Leituras":
        crud_listar_dados()
    elif crud_opcao == "‚úèÔ∏è Atualizar Leitura":
        crud_atualizar_dados()
    elif crud_opcao == "üóëÔ∏è Remover Leitura":
        crud_remover_dados()
    elif crud_opcao == "üìä Estat√≠sticas dos Dados":
        crud_estatisticas()
    elif crud_opcao == "üîé Consulta por Umidade":
        crud_consulta_umidade()
    else:
        st.info("üëÜ Selecione uma opera√ß√£o no menu acima para come√ßar")
        
        # Mostra preview das √∫ltimas leituras
        st.subheader("üìä √öltimas Leituras (Preview)")
        try:
            conn, cursor = conectar_postgres()
            if conn:
                cursor.execute(f"""
                    SELECT id, data_hora_leitura, umidade, temperatura, ph, fosforo, potassio, bomba_dagua 
                    FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                    ORDER BY data_hora_leitura DESC
                    LIMIT 5
                """)
                rows = cursor.fetchall()
                
                if rows:
                    df = pd.DataFrame(rows, columns=[
                        'ID', 'Data/Hora', 'Umidade (%)', 'Temp (¬∞C)', 'pH', 'F√≥sforo', 'Pot√°ssio', 'Bomba'
                    ])
                    
                    # Formata as colunas boolean
                    df['F√≥sforo'] = df['F√≥sforo'].apply(lambda x: "‚úÖ" if x else "‚ùå")
                    df['Pot√°ssio'] = df['Pot√°ssio'].apply(lambda x: "‚úÖ" if x else "‚ùå")
                    df['Bomba'] = df['Bomba'].apply(lambda x: "‚úÖ" if x else "‚ùå")
                    
                    st.dataframe(df, use_container_width=True)
                    st.caption("Mostrando apenas os 5 registros mais recentes")
                else:
                    st.warning("‚ö†Ô∏è Nenhum registro encontrado")
                
                cursor.close()
                conn.close()
        except Exception as e:
            st.error(f"‚ùå Erro ao buscar dados: {e}")

# === FUN√á√ïES PARA MACHINE LEARNING COM SCIKIT-LEARN ===

def preparar_dados_ml():
    """Prepara dados do banco para Machine Learning com dados meteorol√≥gicos"""
    try:
        conn, cursor = conectar_postgres()
        if conn:
            # Primeiro tenta usar dados integrados (com meteorologia)
            cursor.execute(f"""
                SELECT COUNT(*) FROM {DatabaseConfig.SCHEMA}.leituras_integradas
            """)
            count_integradas = cursor.fetchone()[0]
            
            if count_integradas > 10:
                # Usa dados integrados completos
                cursor.execute(f"""
                    SELECT umidade_solo, temperatura_solo, ph_solo, fosforo, potassio, bomba_dagua,
                           temperatura_externa, umidade_ar, pressao_atmosferica, velocidade_vento,
                           probabilidade_chuva, quantidade_chuva, diferenca_temperatura,
                           deficit_umidade, fator_evapotranspiracao, hora_do_dia, dia_semana,
                           mes, vai_chover_hoje, vento_forte, dia_quente
                    FROM {DatabaseConfig.SCHEMA}.view_ml_completa
                    WHERE umidade_solo IS NOT NULL AND temperatura_solo IS NOT NULL
                    ORDER BY data_hora_leitura DESC
                    LIMIT 1000
                """)
                rows = cursor.fetchall()
                
                if rows:
                    df = pd.DataFrame(rows, columns=[
                        'umidade_solo', 'temperatura_solo', 'ph_solo', 'fosforo', 'potassio', 
                        'bomba_dagua', 'temperatura_externa', 'umidade_ar', 'pressao_atmosferica',
                        'velocidade_vento', 'probabilidade_chuva', 'quantidade_chuva',
                        'diferenca_temperatura', 'deficit_umidade', 'fator_evapotranspiracao',
                        'hora_do_dia', 'dia_semana', 'mes', 'vai_chover_hoje', 'vento_forte', 'dia_quente'
                    ])
                    
                    # Renomeia colunas para compatibilidade
                    df = df.rename(columns={
                        'umidade_solo': 'umidade',
                        'temperatura_solo': 'temperatura', 
                        'ph_solo': 'ph'
                    })
                    
                    cursor.close()
                    conn.close()
                    st.success(f"‚úÖ Usando dados INTEGRADOS com meteorologia: {len(df)} registros")
                    return df
            
            # Fallback: usa dados b√°sicos dos sensores
            cursor.execute(f"""
                SELECT umidade, temperatura, ph, fosforo, potassio, bomba_dagua,
                       EXTRACT(HOUR FROM data_hora_leitura) as hora_do_dia,
                       EXTRACT(DOW FROM data_hora_leitura) as dia_semana,
                       EXTRACT(MONTH FROM data_hora_leitura) as mes
                FROM {DatabaseConfig.SCHEMA}.leituras_sensores 
                WHERE umidade IS NOT NULL AND temperatura IS NOT NULL AND ph IS NOT NULL
                ORDER BY data_hora_leitura DESC
                LIMIT 1000
            """)
            rows = cursor.fetchall()
            
            if len(rows) > 10:  # M√≠nimo de dados para ML
                df = pd.DataFrame(rows, columns=[
                    'umidade', 'temperatura', 'ph', 'fosforo', 'potassio', 
                    'bomba_dagua', 'hora_do_dia', 'dia_semana', 'mes'
                ])
                
                # Converte booleanos para num√©rico
                df['fosforo'] = df['fosforo'].astype(int)
                df['potassio'] = df['potassio'].astype(int)
                df['bomba_dagua'] = df['bomba_dagua'].astype(int)
                
                cursor.close()
                conn.close()
                st.info(f"‚ÑπÔ∏è Usando dados B√ÅSICOS (sem meteorologia): {len(df)} registros")
                return df
            else:
                st.warning("‚ö†Ô∏è Dados insuficientes para Machine Learning (m√≠nimo 10 registros)")
                cursor.close()
                conn.close()
                return None
    except Exception as e:
        st.error(f"‚ùå Erro ao preparar dados para ML: {e}")
        return None

def treinar_modelo_irrigacao(df):
    """Treina modelo para prever necessidade de irriga√ß√£o com dados meteorol√≥gicos"""
    try:
        # Features b√°sicas
        features_basicas = ['temperatura', 'ph', 'fosforo', 'potassio', 'hora_do_dia', 'dia_semana', 'mes']
        
        # Features meteorol√≥gicas (se dispon√≠veis)
        features_meteorologicas = [
            'temperatura_externa', 'umidade_ar', 'pressao_atmosferica', 'velocidade_vento',
            'probabilidade_chuva', 'quantidade_chuva', 'diferenca_temperatura', 
            'deficit_umidade', 'fator_evapotranspiracao', 'vai_chover_hoje', 'vento_forte', 'dia_quente'
        ]
        
        # Verifica quais features est√£o dispon√≠veis
        features_disponiveis = []
        for feat in features_basicas:
            if feat in df.columns:
                features_disponiveis.append(feat)
        
        for feat in features_meteorologicas:
            if feat in df.columns:
                features_disponiveis.append(feat)
        
        X = df[features_disponiveis]
        
        # Log das features utilizadas
        if any(feat in df.columns for feat in features_meteorologicas):
            st.info(f"üå§Ô∏è Usando {len(features_disponiveis)} features (incluindo meteorologia)")
        else:
            st.info(f"üìä Usando {len(features_disponiveis)} features b√°sicas")
        
        # Target (vari√°vel dependente) - bomba de irriga√ß√£o
        y = df['bomba_dagua']
        
        # Divide dados em treino e teste
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # Treina modelo Random Forest
        modelo = RandomForestClassifier(n_estimators=100, random_state=42)
        modelo.fit(X_train, y_train)
        
        # Avalia modelo
        y_pred = modelo.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)
        
        # Import√¢ncia das features
        feature_importance = pd.DataFrame({
            'feature': features_disponiveis,
            'importance': modelo.feature_importances_
        }).sort_values('importance', ascending=False)
        
        return modelo, accuracy, feature_importance, X_test, y_test, y_pred
        
    except Exception as e:
        st.error(f"‚ùå Erro ao treinar modelo: {e}")
        return None, None, None, None, None, None

def treinar_modelo_umidade(df):
    """Treina modelo para prever umidade futura com dados meteorol√≥gicos"""
    try:
        # Features b√°sicas para prever umidade
        features_basicas = ['temperatura', 'ph', 'fosforo', 'potassio', 'bomba_dagua', 'hora_do_dia', 'mes']
        
        # Features meteorol√≥gicas que afetam umidade do solo
        features_meteorologicas = [
            'temperatura_externa', 'umidade_ar', 'pressao_atmosferica', 'velocidade_vento',
            'probabilidade_chuva', 'quantidade_chuva', 'diferenca_temperatura', 
            'fator_evapotranspiracao', 'vai_chover_hoje', 'vento_forte', 'dia_quente'
        ]
        
        # Verifica quais features est√£o dispon√≠veis
        features_disponiveis = []
        for feat in features_basicas:
            if feat in df.columns:
                features_disponiveis.append(feat)
        
        for feat in features_meteorologicas:
            if feat in df.columns:
                features_disponiveis.append(feat)
        
        X = df[features_disponiveis]
        y = df['umidade']
        
        # Divide dados
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # Normaliza dados
        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)
        
        # Treina modelo
        modelo = RandomForestRegressor(n_estimators=100, random_state=42)
        modelo.fit(X_train_scaled, y_train)
        
        # Avalia modelo
        y_pred = modelo.predict(X_test_scaled)
        mse = mean_squared_error(y_test, y_pred)
        rmse = np.sqrt(mse)
        
        # Import√¢ncia das features
        feature_importance = pd.DataFrame({
            'feature': features_disponiveis,
            'importance': modelo.feature_importances_
        }).sort_values('importance', ascending=False)
        
        return modelo, scaler, rmse, feature_importance, X_test, y_test, y_pred
        
    except Exception as e:
        st.error(f"‚ùå Erro ao treinar modelo de umidade: {e}")
        return None, None, None, None, None, None, None

def prever_irrigacao_inteligente(modelo_irrigacao, modelo_umidade, scaler, hora_atual=None):
    """Faz previs√µes inteligentes de irriga√ß√£o"""
    try:
        if hora_atual is None:
            hora_atual = datetime.now().hour
        
        # Cen√°rios de teste
        cenarios = [
            {"temperatura": 25, "ph": 6.5, "fosforo": 1, "potassio": 1, "hora_do_dia": hora_atual, "dia_semana": 1},
            {"temperatura": 30, "ph": 6.0, "fosforo": 0, "potassio": 1, "hora_do_dia": hora_atual, "dia_semana": 1},
            {"temperatura": 35, "ph": 7.0, "fosforo": 1, "potassio": 0, "hora_do_dia": hora_atual, "dia_semana": 1},
        ]
        
        resultados = []
        
        for i, cenario in enumerate(cenarios):
            # Previs√£o de irriga√ß√£o
            X_irrig = np.array([[cenario["temperatura"], cenario["ph"], cenario["fosforo"], 
                               cenario["potassio"], cenario["hora_do_dia"], cenario["dia_semana"]]])
            prob_irrigacao = modelo_irrigacao.predict_proba(X_irrig)[0][1]  # Probabilidade de irrigar
            
            # Previs√£o de umidade (com e sem irriga√ß√£o)
            X_umid_sem = np.array([[cenario["temperatura"], cenario["ph"], cenario["fosforo"], 
                                  cenario["potassio"], 0, cenario["hora_do_dia"]]])
            X_umid_com = np.array([[cenario["temperatura"], cenario["ph"], cenario["fosforo"], 
                                  cenario["potassio"], 1, cenario["hora_do_dia"]]])
            
            X_umid_sem_scaled = scaler.transform(X_umid_sem)
            X_umid_com_scaled = scaler.transform(X_umid_com)
            
            umidade_sem_irrigacao = modelo_umidade.predict(X_umid_sem_scaled)[0]
            umidade_com_irrigacao = modelo_umidade.predict(X_umid_com_scaled)[0]
            
            # Recomenda√ß√£o inteligente
            if prob_irrigacao > 0.5 or umidade_sem_irrigacao < 30:
                recomendacao = "üü¢ IRRIGAR"
                motivo = f"Prob: {prob_irrigacao:.2f} | Umidade esperada sem irriga√ß√£o: {umidade_sem_irrigacao:.1f}%"
            else:
                recomendacao = "üî¥ N√ÉO IRRIGAR"
                motivo = f"Prob: {prob_irrigacao:.2f} | Umidade atual suficiente: {umidade_sem_irrigacao:.1f}%"
            
            resultados.append({
                "cenario": f"Cen√°rio {i+1}",
                "temperatura": cenario["temperatura"],
                "ph": cenario["ph"],
                "nutrientes": f"P:{cenario['fosforo']} K:{cenario['potassio']}",
                "prob_irrigacao": prob_irrigacao,
                "umidade_sem_irrig": umidade_sem_irrigacao,
                "umidade_com_irrig": umidade_com_irrigacao,
                "recomendacao": recomendacao,
                "motivo": motivo
            })
        
        return resultados
        
    except Exception as e:
        st.error(f"‚ùå Erro nas previs√µes: {e}")
        return []

def pagina_ml_scikit():
    """P√°gina dedicada ao Machine Learning com Scikit-learn"""
    st.title("ü§ñ Machine Learning com Scikit-learn")
    st.markdown("**Modelo preditivo inteligente para irriga√ß√£o automatizada**")
    
    # Bot√£o para voltar ao dashboard
    if st.button("üè† Voltar ao Dashboard", type="primary"):
        st.session_state.current_page = "dashboard"
        st.rerun()
    
    st.markdown("---")
    
    # Informa√ß√µes do sistema
    col1, col2, col3 = st.columns(3)
    with col1:
        st.info(f"üß† **Algoritmo:** Random Forest")
    with col2:
        st.info(f"üìä **Biblioteca:** Scikit-learn")
    with col3:
        st.info(f"üéØ **Objetivo:** Irriga√ß√£o Inteligente")
    
    st.markdown("---")
    
    # Preparar dados
    with st.spinner("üìä Carregando dados para Machine Learning..."):
        df = preparar_dados_ml()
    
    if df is not None and len(df) > 10:
        st.success(f"‚úÖ Dados carregados: {len(df)} registros para an√°lise ML")
        
        # Estat√≠sticas dos dados
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üìä Total Registros", len(df))
        with col2:
            irrigacoes = df['bomba_dagua'].sum()
            st.metric("üíß Irriga√ß√µes", f"{irrigacoes}")
        with col3:
            umidade_media = df['umidade'].mean()
            st.metric("üìà Umidade M√©dia", f"{umidade_media:.1f}%")
        with col4:
            temp_media = df['temperatura'].mean()
            st.metric("üå°Ô∏è Temp M√©dia", f"{temp_media:.1f}¬∞C")
        
        st.markdown("---")
        
        # Sele√ß√£o de modelos
        ml_opcao = st.selectbox(
            "**Selecione o modelo de Machine Learning:**",
            [
                "Selecione um modelo...",
                "üéØ Modelo de Previs√£o de Irriga√ß√£o",
                "üìä Modelo de Previs√£o de Umidade",
                "ü§ñ Sistema Inteligente Completo",
                "üìà An√°lise de Import√¢ncia das Vari√°veis"
            ]
        )
        
        st.markdown("---")
        
        if ml_opcao == "üéØ Modelo de Previs√£o de Irriga√ß√£o":
            st.subheader("üéØ Previs√£o de Necessidade de Irriga√ß√£o")
            
            if st.button("üöÄ Treinar Modelo de Irriga√ß√£o", use_container_width=True):
                with st.spinner("üß† Treinando modelo Random Forest..."):
                    modelo, accuracy, feature_importance, X_test, y_test, y_pred = treinar_modelo_irrigacao(df)
                
                if modelo is not None:
                    st.success(f"‚úÖ Modelo treinado com sucesso!")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("üéØ Acur√°cia do Modelo", f"{accuracy:.3f}")
                        
                        # Matriz de confus√£o simples
                        from sklearn.metrics import confusion_matrix
                        cm = confusion_matrix(y_test, y_pred)
                        st.text("üìä Matriz de Confus√£o:")
                        st.dataframe(pd.DataFrame(cm, 
                                               columns=['Pred: N√£o Irrigar', 'Pred: Irrigar'],
                                               index=['Real: N√£o Irrigar', 'Real: Irrigar']))
                    
                    with col2:
                        st.text("üìà Import√¢ncia das Vari√°veis:")
                        fig_importance = px.bar(feature_importance, 
                                              x='importance', 
                                              y='feature',
                                              orientation='h',
                                              title="Import√¢ncia das Features")
                        st.plotly_chart(fig_importance, use_container_width=True)
        
        elif ml_opcao == "üìä Modelo de Previs√£o de Umidade":
            st.subheader("üìä Previs√£o de Umidade do Solo")
            
            if st.button("üöÄ Treinar Modelo de Umidade", use_container_width=True):
                with st.spinner("üß† Treinando modelo Random Forest..."):
                    modelo, scaler, rmse, feature_importance, X_test, y_test, y_pred = treinar_modelo_umidade(df)
                
                if modelo is not None:
                    st.success(f"‚úÖ Modelo de umidade treinado!")
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("üìè RMSE", f"{rmse:.2f}%")
                        
                        # Gr√°fico de predi√ß√£o vs real
                        fig_pred = px.scatter(x=y_test, y=y_pred,
                                            labels={'x': 'Umidade Real (%)', 'y': 'Umidade Prevista (%)'},
                                            title="Predi√ß√£o vs Realidade")
                        fig_pred.add_shape(type="line", x0=y_test.min(), y0=y_test.min(), 
                                         x1=y_test.max(), y1=y_test.max(), line=dict(color="red", dash="dash"))
                        st.plotly_chart(fig_pred, use_container_width=True)
                    
                    with col2:
                        st.text("üìà Import√¢ncia das Vari√°veis:")
                        fig_importance = px.bar(feature_importance, 
                                              x='importance', 
                                              y='feature',
                                              orientation='h',
                                              title="Import√¢ncia das Features")
                        st.plotly_chart(fig_importance, use_container_width=True)
        
        elif ml_opcao == "ü§ñ Sistema Inteligente Completo":
            st.subheader("ü§ñ Sistema de Irriga√ß√£o Inteligente")
            
            col1, col2 = st.columns(2)
            with col1:
                if st.button("üöÄ Treinar Modelo de Irriga√ß√£o", use_container_width=True):
                    with st.spinner("üß† Treinando modelo de irriga√ß√£o..."):
                        modelo_irrig, accuracy, _, _, _, _ = treinar_modelo_irrigacao(df)
                        if modelo_irrig:
                            st.session_state.modelo_irrigacao = modelo_irrig
                            st.success(f"‚úÖ Modelo irriga√ß√£o: {accuracy:.3f}")
            
            with col2:
                if st.button("üöÄ Treinar Modelo de Umidade", use_container_width=True):
                    with st.spinner("üß† Treinando modelo de umidade..."):
                        modelo_umid, scaler, rmse, _, _, _, _ = treinar_modelo_umidade(df)
                        if modelo_umid:
                            st.session_state.modelo_umidade = modelo_umid
                            st.session_state.scaler_umidade = scaler
                            st.success(f"‚úÖ Modelo umidade: RMSE {rmse:.2f}")
            
            st.markdown("---")
            
            # Sistema de recomenda√ß√µes
            if st.button("üîÆ Gerar Recomenda√ß√µes Inteligentes", use_container_width=True):
                if (hasattr(st.session_state, 'modelo_irrigacao') and 
                    hasattr(st.session_state, 'modelo_umidade') and
                    hasattr(st.session_state, 'scaler_umidade')):
                    
                    with st.spinner("ü§ñ Calculando recomenda√ß√µes..."):
                        recomendacoes = prever_irrigacao_inteligente(
                            st.session_state.modelo_irrigacao,
                            st.session_state.modelo_umidade,
                            st.session_state.scaler_umidade
                        )
                    
                    if recomendacoes:
                        st.subheader("üéØ Recomenda√ß√µes de Irriga√ß√£o")
                        
                        for rec in recomendacoes:
                            with st.expander(f"{rec['cenario']} - {rec['recomendacao']}"):
                                col1, col2, col3 = st.columns(3)
                                with col1:
                                    st.write(f"üå°Ô∏è **Temperatura:** {rec['temperatura']}¬∞C")
                                    st.write(f"‚öóÔ∏è **pH:** {rec['ph']}")
                                    st.write(f"üß™ **Nutrientes:** {rec['nutrientes']}")
                                
                                with col2:
                                    st.write(f"üìä **Prob. Irriga√ß√£o:** {rec['prob_irrigacao']:.3f}")
                                    st.write(f"üíß **Umidade sem irriga√ß√£o:** {rec['umidade_sem_irrig']:.1f}%")
                                    st.write(f"üíß **Umidade com irriga√ß√£o:** {rec['umidade_com_irrig']:.1f}%")
                                
                                with col3:
                                    st.write(f"**{rec['recomendacao']}**")
                                    st.write(rec['motivo'])
                
                else:
                    st.warning("‚ö†Ô∏è Treine ambos os modelos primeiro!")
        
        elif ml_opcao == "üìà An√°lise de Import√¢ncia das Vari√°veis":
            st.subheader("üìà An√°lise de Features")
            
            if st.button("üìä Analisar Import√¢ncia", use_container_width=True):
                modelo_irrig, _, feat_irrig, _, _, _ = treinar_modelo_irrigacao(df)
                modelo_umid, _, _, feat_umid, _, _, _ = treinar_modelo_umidade(df)
                
                if modelo_irrig and modelo_umid:
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.text("üéØ Import√¢ncia para Irriga√ß√£o:")
                        fig1 = px.bar(feat_irrig, x='importance', y='feature', orientation='h',
                                     title="Features mais importantes para Irriga√ß√£o")
                        st.plotly_chart(fig1, use_container_width=True)
                    
                    with col2:
                        st.text("üíß Import√¢ncia para Umidade:")
                        fig2 = px.bar(feat_umid, x='importance', y='feature', orientation='h',
                                     title="Features mais importantes para Umidade")
                        st.plotly_chart(fig2, use_container_width=True)
        
        else:
            st.info("üëÜ Selecione um modelo no menu acima para come√ßar")
            
            # Informa√ß√µes sobre Machine Learning
            st.subheader("ü§ñ Sobre os Modelos de Machine Learning")
            
            col1, col2 = st.columns(2)
            with col1:
                st.markdown("""
                **üéØ Modelo de Irriga√ß√£o:**
                - Algoritmo: Random Forest Classifier
                - Objetivo: Prever se deve irrigar (Sim/N√£o)
                - Features: Temperatura, pH, Nutrientes, Hora
                - M√©trica: Acur√°cia
                """)
            
            with col2:
                st.markdown("""
                **üìä Modelo de Umidade:**
                - Algoritmo: Random Forest Regressor
                - Objetivo: Prever n√≠vel de umidade
                - Features: Temperatura, pH, Bomba, Hora
                - M√©trica: RMSE (Erro Quadr√°tico M√©dio)
                """)
            
            st.markdown("""
            **üß† Sistema Inteligente:**
            
            O sistema combina ambos os modelos para tomar decis√µes inteligentes:
            1. **Coleta dados** dos sensores (temperatura, pH, nutrientes)
            2. **Coleta dados meteorol√≥gicos** (chuva, vento, press√£o)
            3. **Calcula probabilidade** de necessidade de irriga√ß√£o
            4. **Prev√™ umidade** com e sem irriga√ß√£o
            5. **Gera recomenda√ß√£o** baseada em m√∫ltiplos fatores
            6. **Aprende continuamente** com novos dados
            
            **Benef√≠cios com Meteorologia:**
            - ‚úÖ N√£o irriga se vai chover
            - ‚úÖ Considera evapora√ß√£o por vento
            - ‚úÖ Otimiza baseado na press√£o atmosf√©rica
            - ‚úÖ Ajusta para umidade do ar
            - ‚úÖ Economia de √°gua inteligente
            """)
        
        # Se√ß√£o sobre dados meteorol√≥gicos
        st.subheader("üå§Ô∏è Integra√ß√£o Meteorol√≥gica")
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("""
            **üìä Dados Coletados:**
            - üå°Ô∏è Temperatura externa
            - üíß Umidade do ar
            - üå™Ô∏è Velocidade do vento
            - üìä Press√£o atmosf√©rica
            - üåßÔ∏è Probabilidade de chuva
            - ‚òÄÔ∏è √çndice UV
            """)
        
        with col2:
            st.markdown("""
            **üß† Como a IA Usa:**
            - Se prob. chuva > 70% ‚Üí N√ÉO irrigar
            - Se vento forte ‚Üí Aumentar irriga√ß√£o
            - Se press√£o baixa ‚Üí Aguardar chuva
            - Se temp. alta ‚Üí Irrigar mais cedo
            - Se umidade ar baixa ‚Üí Irrigar mais
            """)
    
    else:
        st.error("‚ùå Dados insuficientes para Machine Learning")
        st.info("üí° Aguarde mais dados serem coletados pelos sensores ou insira dados manualmente via CRUD")
        
        # Bot√£o para popular dados de teste
        if st.button("üé≤ Gerar Dados de Teste para ML", use_container_width=True):
            with st.spinner("üîÑ Gerando dados de teste..."):
                dados_gerados = gerar_dados_teste_ml()
                if dados_gerados > 0:
                    st.success(f"‚úÖ {dados_gerados} registros de teste gerados!")
                    st.info("üîÑ Recarregue a p√°gina para treinar os modelos")

def gerar_dados_teste_ml():
    """Gera dados de teste para demonstrar o ML"""
    try:
        import random
        from datetime import datetime, timedelta
        
        dados_gerados = 0
        
        # Gera 50 registros de teste dos √∫ltimos 7 dias
        for i in range(50):
            # Data aleat√≥ria nos √∫ltimos 7 dias
            data_base = datetime.now() - timedelta(days=random.randint(0, 7))
            data_base = data_base - timedelta(
                hours=random.randint(0, 23),
                minutes=random.randint(0, 59)
            )
            
            # Dados dos sensores
            umidade = random.uniform(20, 80)
            temperatura = random.uniform(18, 35)
            ph = random.uniform(5.5, 8.0)
            fosforo = random.choice([True, False])
            potassio = random.choice([True, False])
            
            # L√≥gica para bomba (baseada em umidade)
            bomba = umidade < 35 or (umidade < 50 and temperatura > 30)
            
            # Dados meteorol√≥gicos simulados
            temp_externa = temperatura + random.uniform(-3, 5)
            umidade_ar = random.uniform(45, 95)
            pressao = random.uniform(1000, 1025)
            vento = random.uniform(2, 20)
            prob_chuva = random.uniform(0, 100)
            chuva = random.uniform(0, 8) if prob_chuva > 70 else 0
            
            dados_meteorologicos = {
                'temperatura_externa': temp_externa,
                'umidade_ar': umidade_ar,
                'pressao_atmosferica': pressao,
                'velocidade_vento': vento,
                'direcao_vento': random.choice(['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']),
                'condicao_clima': random.choice(['Ensolarado', 'Nublado', 'Chuva leve', 'Chuva']),
                'probabilidade_chuva': prob_chuva,
                'quantidade_chuva': chuva,
                'indice_uv': random.uniform(0, 11),
                'visibilidade': random.uniform(5, 30),
                'cidade': 'Camopi (Teste)',
                'fonte_dados': 'Dados de Teste'
            }
            
            dados_sensores = {
                'umidade': umidade,
                'temperatura': temperatura,
                'ph': ph,
                'fosforo': fosforo,
                'potassio': potassio,
                'bomba_dagua': bomba
            }
            
            # Salva dados meteorol√≥gicos
            if salvar_dados_meteorologicos(dados_meteorologicos):
                # Cria leitura integrada
                if criar_leitura_integrada(dados_sensores, dados_meteorologicos):
                    dados_gerados += 1
        
        return dados_gerados
        
    except Exception as e:
        st.error(f"‚ùå Erro ao gerar dados de teste: {e}")
        return 0

# === FUN√á√ïES PARA DADOS METEOROL√ìGICOS ===

@st.cache_data(ttl=300)  # Cache por 5 minutos
def coletar_dados_meteorologicos():
    """Coleta dados meteorol√≥gicos da API OpenWeatherMap"""
    try:
        # Para demonstra√ß√£o, vamos usar dados simulados mais realistas
        # Em produ√ß√£o, descomente e configure a API real
        
        import random
        from datetime import datetime
        
        # Simula condi√ß√µes clim√°ticas mais realistas baseadas na hora
        hora_atual = datetime.now().hour
        
        # Temperatura varia conforme o hor√°rio
        if 6 <= hora_atual <= 12:  # Manh√£
            temp_base = 24 + random.uniform(-2, 3)
        elif 12 <= hora_atual <= 18:  # Tarde
            temp_base = 29 + random.uniform(-3, 4)
        elif 18 <= hora_atual <= 22:  # Noite
            temp_base = 26 + random.uniform(-2, 2)
        else:  # Madrugada
            temp_base = 22 + random.uniform(-1, 2)
        
        # Umidade do ar inversamente relacionada √† temperatura
        umidade_ar = max(45, min(95, 85 - (temp_base - 22) * 2 + random.uniform(-5, 5)))
        
        # Press√£o atmosf√©rica com varia√ß√£o realista
        pressao = 1013.25 + random.uniform(-15, 15)
        
        # Vento com padr√µes diurnos
        if 10 <= hora_atual <= 16:  # Ventos mais fortes durante o dia
            vento = random.uniform(8, 18)
        else:  # Ventos mais calmos √† noite
            vento = random.uniform(3, 12)
        
        # Probabilidade de chuva baseada em umidade e press√£o
        if umidade_ar > 80 and pressao < 1010:
            prob_chuva = random.uniform(60, 95)
        elif umidade_ar > 70:
            prob_chuva = random.uniform(20, 60)
        else:
            prob_chuva = random.uniform(0, 20)
        
        # Quantidade de chuva se probabilidade for alta
        if prob_chuva > 70:
            chuva = random.uniform(0.5, 8.0)
        elif prob_chuva > 40:
            chuva = random.uniform(0.0, 2.0)
        else:
            chuva = 0.0
        
        # Condi√ß√µes clim√°ticas baseadas em chuva e temperatura
        if chuva > 2:
            condicao = random.choice(["Chuva forte", "Tempestade", "Chuva"])
        elif chuva > 0:
            condicao = random.choice(["Chuva leve", "Garoa", "Chuvisco"])
        elif temp_base > 30:
            condicao = random.choice(["Ensolarado", "Muito quente", "C√©u limpo"])
        elif umidade_ar > 80:
            condicao = random.choice(["Nublado", "Muito √∫mido", "Neblina"])
        else:
            condicao = random.choice(["Parcialmente nublado", "Ensolarado", "C√©u limpo"])
        
        # Dire√ß√£o do vento
        direcoes = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"]
        direcao_vento = random.choice(direcoes)
        
        # √çndice UV baseado na hora e condi√ß√µes
        if 10 <= hora_atual <= 16 and "Ensolarado" in condicao:
            indice_uv = random.uniform(6, 11)
        elif 8 <= hora_atual <= 18:
            indice_uv = random.uniform(2, 8)
        else:
            indice_uv = random.uniform(0, 2)
        
        # Visibilidade baseada em chuva e umidade
        if chuva > 5:
            visibilidade = random.uniform(2, 8)
        elif umidade_ar > 85:
            visibilidade = random.uniform(8, 15)
        else:
            visibilidade = random.uniform(15, 30)
        
        dados_meteorologicos = {
            'temperatura_externa': round(temp_base, 1),
            'umidade_ar': round(umidade_ar, 1),
            'pressao_atmosferica': round(pressao, 2),
            'velocidade_vento': round(vento, 1),
            'direcao_vento': direcao_vento,
            'condicao_clima': condicao,
            'probabilidade_chuva': round(prob_chuva, 1),
            'quantidade_chuva': round(chuva, 1),
            'indice_uv': round(indice_uv, 1),
            'visibilidade': round(visibilidade, 1),
            'cidade': 'Camopi (Simulado)',
            'fonte_dados': 'Simula√ß√£o Inteligente'
        }
        
        return dados_meteorologicos
        
    except Exception as e:
        st.error(f"‚ùå Erro ao coletar dados meteorol√≥gicos: {e}")
        return None

def salvar_dados_meteorologicos(dados_met):
    """Salva dados meteorol√≥gicos no banco PostgreSQL"""
    try:
        conn, cursor = conectar_postgres()
        if conn and dados_met:
            cursor.execute(f"""
                INSERT INTO {DatabaseConfig.SCHEMA}.dados_meteorologicos 
                (temperatura_externa, umidade_ar, pressao_atmosferica, velocidade_vento, 
                 direcao_vento, condicao_clima, probabilidade_chuva, quantidade_chuva,
                 indice_uv, visibilidade, cidade, fonte_dados)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                dados_met['temperatura_externa'],
                dados_met['umidade_ar'], 
                dados_met['pressao_atmosferica'],
                dados_met['velocidade_vento'],
                dados_met['direcao_vento'],
                dados_met['condicao_clima'],
                dados_met['probabilidade_chuva'],
                dados_met['quantidade_chuva'],
                dados_met['indice_uv'],
                dados_met['visibilidade'],
                dados_met['cidade'],
                dados_met['fonte_dados']
            ))
            conn.commit()
            cursor.close()
            conn.close()
            return True
    except Exception as e:
        st.error(f"‚ùå Erro ao salvar dados meteorol√≥gicos: {e}")
        return False

def calcular_fatores_evapotranspiracao(temp_solo, temp_externa, umidade_ar, vento):
    """Calcula fatores que afetam a evapotranspira√ß√£o"""
    try:
        # Diferen√ßa de temperatura (externa - solo)
        diferenca_temp = temp_externa - temp_solo
        
        # D√©ficit de umidade (ar - solo) - aproxima√ß√£o
        # Assumindo que umidade do solo ideal √© ~40-60%
        deficit_umidade = umidade_ar - 50  # Refer√™ncia
        
        # Fator de evapotranspira√ß√£o baseado em Penman-Monteith simplificado
        # ET = f(temperatura, vento, d√©ficit de umidade)
        fator_et = (temp_externa * 0.3) + (vento * 0.2) - (umidade_ar * 0.1)
        fator_et = max(0, fator_et)  # N√£o pode ser negativo
        
        return diferenca_temp, deficit_umidade, fator_et
        
    except Exception:
        return 0, 0, 0

def criar_leitura_integrada(dados_sensores, dados_meteorologicos):
    """Combina dados dos sensores com dados meteorol√≥gicos"""
    try:
        # Calcula fatores derivados
        diferenca_temp, deficit_umidade, fator_et = calcular_fatores_evapotranspiracao(
            dados_sensores.get('temperatura', 25),
            dados_meteorologicos.get('temperatura_externa', 25),
            dados_meteorologicos.get('umidade_ar', 70),
            dados_meteorologicos.get('velocidade_vento', 5)
        )
        
        conn, cursor = conectar_postgres()
        if conn:
            cursor.execute(f"""
                INSERT INTO {DatabaseConfig.SCHEMA}.leituras_integradas 
                (umidade_solo, temperatura_solo, ph_solo, fosforo, potassio, bomba_dagua,
                 temperatura_externa, umidade_ar, pressao_atmosferica, velocidade_vento,
                 condicao_clima, probabilidade_chuva, quantidade_chuva,
                 diferenca_temperatura, deficit_umidade, fator_evapotranspiracao)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                dados_sensores.get('umidade', 0),
                dados_sensores.get('temperatura', 0),
                dados_sensores.get('ph', 7.0),
                dados_sensores.get('fosforo', False),
                dados_sensores.get('potassio', False),
                dados_sensores.get('bomba_dagua', False),
                dados_meteorologicos.get('temperatura_externa', 25),
                dados_meteorologicos.get('umidade_ar', 70),
                dados_meteorologicos.get('pressao_atmosferica', 1013),
                dados_meteorologicos.get('velocidade_vento', 5),
                dados_meteorologicos.get('condicao_clima', 'Desconhecido'),
                dados_meteorologicos.get('probabilidade_chuva', 0),
                dados_meteorologicos.get('quantidade_chuva', 0),
                diferenca_temp,
                deficit_umidade,
                fator_et
            ))
            conn.commit()
            cursor.close()
            conn.close()
            return True
    except Exception as e:
        st.error(f"‚ùå Erro ao criar leitura integrada: {e}")
        return False

# --- Fun√ß√£o para consultar a API do tempo ---
@st.cache_data(ttl=300)  # Cache por 5 minutos
def get_clima_atual():
    """Obt√©m dados clim√°ticos simulados (API desabilitada temporariamente)"""
    # API_KEY = "SUA_API_KEY_AQUI"  # <-- Para usar a API real, substitua pela sua chave da OpenWeatherMap
    # CIDADE = "Camopi"
    # URL = f"https://api.openweathermap.org/data/2.5/weather?q={CIDADE}&appid={API_KEY}&units=metric&lang=pt_br"
    
    # VERS√ÉO SIMULADA - Para usar API real, descomente o c√≥digo acima e comente este bloco
    try:
        # Retorna dados simulados para demonstra√ß√£o
        import random
        from datetime import datetime
        
        # Simula condi√ß√µes clim√°ticas vari√°veis
        temp_base = 28
        temp_variacao = random.uniform(-3, 3)
        temperatura_atual = round(temp_base + temp_variacao, 1)
        
        umidade_atual = random.randint(60, 85)
        
        condicoes = ["Ensolarado", "Parcialmente nublado", "Nublado", "C√©u limpo"]
        condicao_atual = random.choice(condicoes)
        
        vento_atual = round(random.uniform(2, 8), 1)
        
        # 20% de chance de chuva para demonstrar o alerta
        vai_chover_hoje = random.random() < 0.2
        chuva_atual = round(random.uniform(0.5, 5.0), 1) if vai_chover_hoje else 0.0

        clima = {
            'cidade': 'Camopi (Simulado)',
            'temperatura': temperatura_atual,
            'umidade': umidade_atual,
            'condicao': condicao_atual,
            'vento': vento_atual,
            'chuva': chuva_atual,
            'vai_chover': vai_chover_hoje
        }

        return clima

    except Exception as e:
        st.warning(f"‚ö†Ô∏è API clim√°tica temporariamente indispon√≠vel. Usando dados simulados.")
        return {
            'cidade': 'Camopi (Simulado)',
            'temperatura': 26.5,
            'umidade': 72,
            'condicao': 'Parcialmente nublado',
            'vento': 4.2,
            'chuva': 0.0,
            'vai_chover': False
        }
    
    # C√ìDIGO PARA USO REAL DA API (descomente para usar):
    # try:
    #     response = requests.get(URL, timeout=5)
    #     response.raise_for_status()
    #     dados = response.json()
    #
    #     clima = {
    #         'cidade': dados.get("name", "Desconhecida"),
    #         'temperatura': dados.get("main", {}).get("temp", "N/A"),
    #         'umidade': dados.get("main", {}).get("humidity", "N/A"),
    #         'condicao': dados.get("weather", [{}])[0].get("description", "N/A").capitalize(),
    #         'vento': dados.get("wind", {}).get("speed", "N/A"),
    #         'chuva': dados.get("rain", {}).get("1h", 0.0)
    #     }
    #
    #     clima['vai_chover'] = clima['chuva'] > 0
    #     return clima
    #
    # except Exception as e:
    #     st.error(f"Erro ao consultar clima: {e}")
    #     return {
    #         'cidade': 'Erro',
    #         'temperatura': 'N/A',
    #         'umidade': 'N/A',
    #         'condicao': 'Erro ao consultar clima',
    #         'vento': 'N/A',
    #         'chuva': 'N/A',
    #         'vai_chover': False
    #     }

# --- Fun√ß√£o para obter os dados do Flask ---
@st.cache_data(ttl=2)  # Cache por 2 segundos para refresh mais r√°pido
def get_sensor_data():
    """Obt√©m dados dos sensores do servidor Flask"""
    try:
        response = requests.get(FLASK_SERVER_URL, timeout=5)
        response.raise_for_status()
        data = response.json()
        
        if 'dados' in data and data['dados']:
            return data
        else:
            return None
            
    except requests.exceptions.RequestException as e:
        st.error(f"Erro ao conectar com o servidor Flask: {e}")
        return None

def init_session_state():
    """Inicializa as vari√°veis do session_state"""
    if 'current_page' not in st.session_state:
        st.session_state.current_page = "dashboard"
    
    if 'crud_opcao' not in st.session_state:
        st.session_state.crud_opcao = "Selecione uma opera√ß√£o..."
    
    if 'analytics_opcao' not in st.session_state:
        st.session_state.analytics_opcao = "Selecione uma an√°lise..."

# --- Interface principal ---
def main():
    # Inicializa sistema de navega√ß√£o por p√°ginas PRIMEIRO
    init_session_state()
    
    # T√≠tulo principal
    st.title("üå± FarmTech Solutions Dashboard")
    
    # Bot√µes de navega√ß√£o principal - Agora com 4 colunas
    col1, col2, col3, col4 = st.columns([1, 1, 1, 1])
    
    with col1:
        if st.button("üóÉÔ∏è Gerenciamento CRUD", use_container_width=True, type="primary"):
            st.session_state.current_page = "crud"
            st.rerun()
    
    with col2:
        # M√©todo mais confi√°vel usando markdown com link direto
        st.markdown("""
        <a href="http://localhost:8000/plotter" target="_self">
            <button style="
                width: 100%;
                height: 38px;
                background-color: #ff4b4b;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 400;
                padding: 0 12px;
            ">
                üìà Live Plotter
            </button>
        </a>
        """, unsafe_allow_html=True)
    
    with col3:
        if st.button("ü§ñ An√°lise R", use_container_width=True, type="secondary"):
            st.session_state.current_page = "analytics"
            st.rerun()
    
    with col4:
        if st.button("üß† Machine Learning", use_container_width=True, type="secondary"):
            st.session_state.current_page = "ml"
            st.rerun()
    
    st.markdown("---")
    
    # Navega para a p√°gina correta
    current_page = getattr(st.session_state, 'current_page', 'dashboard')
    if current_page == "crud":
        pagina_crud()
        return  # Sai da fun√ß√£o para n√£o mostrar o dashboard
    elif current_page == "analytics":
        pagina_analytics_r()
        return  # Sai da fun√ß√£o para n√£o mostrar o dashboard
    elif current_page == "ml":
        pagina_ml_scikit()
        return  # Sai da fun√ß√£o para n√£o mostrar o dashboard
    
    # === DASHBOARD PRINCIPAL ===
    
    # Sidebar para controles
    with st.sidebar:
        st.header("‚öôÔ∏è Controles")
        auto_refresh = st.checkbox("üîÑ Atualiza√ß√£o Autom√°tica", value=True)
        refresh_interval = st.slider("Intervalo (segundos)", 3, 60, 45)
        
        # Checkbox para coleta autom√°tica de dados meteorol√≥gicos
        coletar_meteorologia = st.checkbox("üå§Ô∏è Coletar Meteorologia", value=True)
        
        if st.button("üîÑ Atualizar Dados"):
            st.cache_data.clear()
            st.rerun()
        
        # Se habilitado, coleta e salva dados meteorol√≥gicos
        if coletar_meteorologia:
            dados_met = coletar_dados_meteorologicos()
            if dados_met:
                # Salva no banco a cada 10 minutos (para n√£o sobrecarregar)
                if st.session_state.get('ultimo_salvamento_met', 0) + 600 < time.time():
                    if salvar_dados_meteorologicos(dados_met):
                        st.session_state.ultimo_salvamento_met = time.time()
                        st.success("‚òÅÔ∏è Meteorologia salva!", icon="üå§Ô∏è")
        
        st.markdown("---")
        st.header("üìä Servidor")
        st.info(f"URL: {FLASK_SERVER_URL}")
        st.info(f"DB: {DatabaseConfig.HOST}")
        st.info(f"Schema: {DatabaseConfig.SCHEMA}")
    
    # Placeholder para status de conex√£o
    status_placeholder = st.empty()
    
    # Obt√©m dados dos sensores
    sensor_data = get_sensor_data()
    
    if sensor_data and sensor_data.get('dados'):
        # Status de conex√£o
        status_placeholder.success(f"‚úÖ Conectado - {sensor_data.get('total_registros', 0)} registros")
        
        # Converte para DataFrame
        df = pd.DataFrame(sensor_data['dados'])
        
        # Processa timestamps com diferentes formatos
        if 'data_hora_leitura' in df.columns:
            try:
                # Abordagem mais robusta - for√ßa coer√ß√£o de erros
                df['data_hora_leitura'] = pd.to_datetime(df['data_hora_leitura'], errors='coerce')
                df = df.sort_values('data_hora_leitura', ascending=False)
            except Exception as e:
                st.error(f"Erro ao processar timestamps: {e}")
                # Se falhar, usa dados sem ordena√ß√£o por data
                pass
        
        # Dados mais recentes
        if not df.empty:
            ultimo_registro = df.iloc[0]
            
            # === SE√á√ÉO 1: M√âTRICAS PRINCIPAIS ===
            st.header("üìä Dados Atuais")
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                temp_value = ultimo_registro.get('temperatura', 0)
                try:
                    temp_float = float(temp_value)
                    temp_display = f"{temp_float:.1f}¬∞C"
                except:
                    temp_display = f"{temp_value}¬∞C"
                
                st.metric(
                    label="üå°Ô∏è Temperatura",
                    value=temp_display,
                    delta=None
                )
                
            with col2:
                umid_value = ultimo_registro.get('umidade', 0)
                try:
                    umid_float = float(umid_value)
                    umid_display = f"{umid_float:.1f}%"
                except:
                    umid_display = f"{umid_value}%"
                
                st.metric(
                    label="üíß Umidade",
                    value=umid_display,
                    delta=None
                )
                
            with col3:
                ph_value = ultimo_registro.get('ph', 7)
                try:
                    ph_float = float(ph_value)
                    ph_display = f"{ph_float:.1f}"
                except:
                    ph_display = str(ph_value)
                
                st.metric(
                    label="‚öóÔ∏è pH",
                    value=ph_display,
                    delta=None
                )
                
            with col4:
                bomba_status = ultimo_registro.get('bomba_dagua', False)
                if isinstance(bomba_status, str):
                    bomba_ligada = bomba_status.lower() in ['true', 'on', '1']
                else:
                    bomba_ligada = bool(bomba_status)
                    
                st.metric(
                    label="üö∞ Bomba",
                    value="Ligada" if bomba_ligada else "Desligada",
                    delta=None
                )
            
            # === SE√á√ÉO 2: STATUS DOS NUTRIENTES ===
            st.header("üß™ Nutrientes")
            col1, col2 = st.columns(2)
            
            with col1:
                fosforo_value = ultimo_registro.get('fosforo', False)
                if isinstance(fosforo_value, str):
                    fosforo_presente = fosforo_value.lower() in ['true', 'presente', '1']
                else:
                    fosforo_presente = bool(fosforo_value)
                
                if fosforo_presente:
                    st.success("üß™ F√≥sforo: Presente ‚úÖ")
                else:
                    st.error("üß™ F√≥sforo: Ausente ‚ùå")
            
            with col2:
                potassio_value = ultimo_registro.get('potassio', False)
                if isinstance(potassio_value, str):
                    potassio_presente = potassio_value.lower() in ['true', 'presente', '1']
                else:
                    potassio_presente = bool(potassio_value)
                
                if potassio_presente:
                    st.success("üß™ Pot√°ssio: Presente ‚úÖ")
                else:
                    st.error("üß™ Pot√°ssio: Ausente ‚ùå")
            
            # === SE√á√ÉO 3: GR√ÅFICOS ===
            st.header("üìà Tend√™ncias")
            
            if len(df) > 1:
                # Prepara dados para gr√°ficos (√∫ltimos 20 registros)
                df_plot = df.head(20).copy()
                
                # Converte colunas num√©ricas para garantir que sejam n√∫meros
                for col in ['umidade', 'temperatura', 'ph']:
                    if col in df_plot.columns:
                        df_plot[col] = pd.to_numeric(df_plot[col], errors='coerce')
                
                # Remove linhas com valores NaN
                df_plot = df_plot.dropna(subset=['data_hora_leitura'])
                df_plot = df_plot.sort_values('data_hora_leitura')
                
                if not df_plot.empty:
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        # Gr√°fico de Umidade
                        if 'umidade' in df_plot.columns:
                            fig_umidade = px.line(
                                df_plot, 
                                x='data_hora_leitura', 
                                y='umidade',
                                title='üíß Umidade do Solo',
                                labels={'umidade': 'Umidade (%)', 'data_hora_leitura': 'Hor√°rio'}
                            )
                            fig_umidade.update_traces(line_color='#1f77b4')
                            st.plotly_chart(fig_umidade, use_container_width=True)
                    
                    with col2:
                        # Gr√°fico de Temperatura
                        if 'temperatura' in df_plot.columns:
                            fig_temperatura = px.line(
                                df_plot, 
                                x='data_hora_leitura', 
                                y='temperatura',
                                title='üå°Ô∏è Temperatura do Solo',
                                labels={'temperatura': 'Temperatura (¬∞C)', 'data_hora_leitura': 'Hor√°rio'}
                            )
                            fig_temperatura.update_traces(line_color='#ff7f0e')
                            st.plotly_chart(fig_temperatura, use_container_width=True)
                    
                    # Gr√°fico de pH
                    if 'ph' in df_plot.columns:
                        fig_ph = px.line(
                            df_plot, 
                            x='data_hora_leitura', 
                            y='ph',
                            title='‚öóÔ∏è N√≠vel de pH',
                            labels={'ph': 'pH', 'data_hora_leitura': 'Hor√°rio'}
                        )
                        fig_ph.update_traces(line_color='#2ca02c')
                        fig_ph.add_hline(y=7, line_dash="dash", line_color="red", 
                                       annotation_text="pH Neutro (7)")
                        st.plotly_chart(fig_ph, use_container_width=True)
                else:
                    st.warning("‚ö†Ô∏è Dados insuficientes para gr√°ficos")
            
            # === SE√á√ÉO 4: DADOS CLIM√ÅTICOS ===
            st.header("üå§Ô∏è Condi√ß√µes Clim√°ticas")
            
            clima = get_clima_atual()
            
            if clima and clima.get('cidade') != 'Erro':
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.info(f"üìç **Cidade:** {clima['cidade']}")
                    st.info(f"üå°Ô∏è **Temperatura:** {clima['temperatura']}¬∞C")
                
                with col2:
                    st.info(f"üíß **Umidade:** {clima['umidade']}%")
                    st.info(f"‚òÅÔ∏è **Condi√ß√£o:** {clima['condicao']}")
                
                with col3:
                    st.info(f"üå¨Ô∏è **Vento:** {clima['vento']} m/s")
                    st.info(f"üåßÔ∏è **Chuva:** {clima['chuva']} mm")
                
                # Alerta de chuva
                if clima['vai_chover']:
                    st.warning(f"üåßÔ∏è **ALERTA:** Previs√£o de {clima['chuva']} mm de chuva! Manter bomba d'√°gua desligada!")
                else:
                    st.success("‚òÄÔ∏è Sem previs√£o de chuva nas pr√≥ximas horas.")
            else:
                st.error("‚ùå Erro ao obter dados clim√°ticos")
    
            # === SE√á√ÉO 5: TABELA DE DADOS ===
            st.header("üìã Hist√≥rico de Leituras")
            
            # Prepara dados para exibi√ß√£o
            df_display = df.copy()
            if 'data_hora_leitura' in df_display.columns:
                try:
                    df_display['data_hora_leitura'] = df_display['data_hora_leitura'].dt.strftime('%d/%m/%Y %H:%M:%S')
                except:
                    # Se falhar, mant√©m formato original
                    pass
            
            # Renomeia colunas para melhor exibi√ß√£o
            column_mapping = {
                'id': 'ID',
                'data_hora_leitura': 'Data/Hora',
                'temperatura': 'Temp (¬∞C)',
                'umidade': 'Umidade (%)',
                'ph': 'pH',
                'fosforo': 'F√≥sforo',
                'potassio': 'Pot√°ssio',
                'bomba_dagua': 'Bomba'
            }
            
            df_display = df_display.rename(columns=column_mapping)
            
            # Seleciona colunas para exibir
            cols_to_show = [col for col in column_mapping.values() if col in df_display.columns]
            df_display = df_display[cols_to_show]
            
            st.dataframe(
                df_display.head(10),
                use_container_width=True,
                height=400
            )
        else:
            if sensor_data and sensor_data.get('dados'):
                st.warning("‚ö†Ô∏è Nenhum dado encontrado")
    
    # Mensagem de erro de conex√£o
    if not sensor_data or not sensor_data.get('dados'):
        status_placeholder.error("‚ùå Erro ao conectar com o servidor ou sem dados")
        st.error("Verifique se o servidor Flask est√° rodando em http://127.0.0.1:8000")
    
    # Auto-refresh otimizado
    if auto_refresh:
        # Mostra pr√≥xima atualiza√ß√£o
        with st.empty():
            for i in range(refresh_interval, 0, -1):
                st.caption(f"üîÑ Pr√≥xima atualiza√ß√£o em {i} segundos...")
                time.sleep(1)
        
        # Limpa cache e recarrega
        st.cache_data.clear()
        st.rerun()

# --- Execu√ß√£o principal ---
if __name__ == "__main__":
    main() 